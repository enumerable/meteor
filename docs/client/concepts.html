<template name="concepts">

<h1 id="concepts">Concepts</h1>

我们已经徒手写过大量的单页面 JavaScript 程序了，只一种语言（JavaScript）和一种数据格式（JSON）来写程序
真是一件美事。Meteor 提供了你写这类程序时需要的一切。

{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtml }}
{{> templates }}
{{> packages_concept }}
{{> deploying }}
</template>

<template name="structure">
{{#better_markdown}}

<h2 id="structuringyourapp">架构你的应用</h2>

一个 Meteor 应用由三部分组成：

* 运行在浏览器中的 JavaScript
* 运行在 Meteor 服务端上的 Node.js 运行时中的 JavaScript
* HTML 片段，CSS 规则，以及一些静态文件

Meteor 会自动打包并传送这不同的几部分。And，你可以在你的代码树中很灵活地选择如何架构这些组件。

服务端的唯一组件就是 JavaScript 代码，Meteor 会收集除了 `client` 和 `public` 子文件之外的
所有 JavaScript 文件，并把他们都载入到一个 fiber 中的 Node.js 服务端实例。在 Meteor 中，
每个请求都会让你的服务端启动一个线程，而非 Node.js 传统的异步回调模式。我们发现线性计算模型更适合
典型的 Meteor 服务端代码。

There are more assets to consider on the client side.  Meteor
gathers all JavaScript files in your tree with the exception of
the `server` and `public` subdirectories for the
client.  It minifies this bundle and serves it to each new client.
You're free to use a single JavaScript file for your entire application, or
create a nested tree of separate files, or anything in between.

Some JavaScript libraries only work when placed in the
`client/compatibility` subdirectory.  Files in this directory are
executed without being wrapped in a new variable scope.  This means
that each top-level `var` defines a global variable. In addition,
these files are executed before other client-side JavaScript files.

Files outside the `client`, `server` and `tests` subdirectories are loaded on
both the client and the server!  That's the place for model definitions and
other functions.  Meteor provides the variables [`isClient`](#meteor_isclient) and
[`isServer`](#meteor_isserver) so that your code can alter its behavior depending
on whether it's running on the client or the server. (Files in directories named
`tests` are not loaded anywhere.)

Any sensitive code that you don't want served to the client, such as code
containing passwords or authentication mechanisms, should be
kept in the `server` directory.

CSS files are gathered together as well: the client will get a bundle with all
the CSS in your tree (excluding the `server`
and `public` subdirectories).

In development mode, JavaScript and CSS files are sent individually to make
debugging easier.

HTML files in a Meteor application are treated quite a bit differently
from a server-side framework.  Meteor scans all the HTML files in your
directory for three top-level elements: `<head>`, `<body>`, and
`<template>`.  The head and body sections are separately concatenated
into a single head and body, which are transmitted to the client on
initial page load.

Template sections, on the other hand, are converted into JavaScript
functions, available under the `Template` namespace.  It's
a really convenient way to ship HTML templates to the client.
See the [templates](#templates) section for more.

Lastly, the Meteor server will serve any files under the `public`
directory, just like in a Rails or Django project.  This is the place
for images, `favicon.ico`, `robots.txt`, and anything else.

It is best to write your application in such a way that it is
insensitive to the order in which files are loaded, for example by
using [Meteor.startup](#meteor_startup), or by moving load order
sensitive code into [Smart Packages](#smartpackages), which can explicitly control both
the load order of their contents and their load order with respect to
other packages. However sometimes load order dependencies in your
application are unavoidable. The JavaScript and CSS files in an
application are loaded according to these rules:

* Files in the `lib` directory at the root of your application are
  loaded first.

* Files that match `main.*` are loaded after everything else.

* Files in subdirectories are loaded before files in parent
  directories, so that files in the deepest subdirectory are loaded
  first (after `lib`), and files in the root directory are loaded last
  (other than `main.*`).

* Within a directory, files are loaded in alphabetical order by
  filename.

These rules stack, so that within `lib`, for example, files are still
loaded in alphabetical order; and if there are multiple files named
`main.js`, the ones in subdirectories are loaded earlier.

{{/better_markdown}}
</template>

<template name="data">
{{#better_markdown}}

<h2 id="dataandsecurity">Data and security</h2>

Meteor makes writing distributed client code as simple as talking to a
local database.  It's a clean, simple, and secure approach that obviates
the need to implement individual RPC endpoints, manually cache data on
the client to avoid slow roundtrips to the server, and carefully
orchestrate invalidation messages to every client as data changes.

In Meteor, the client and server share the same database API.  The same
exact application code &mdash; like validators and computed properties &mdash; can
often run in both places.  But while code running on the server has
direct access to the database, code running on the client does *not*.
This distinction is the basis for Meteor's data security model.

{{#note}}
By default, a new Meteor app includes the `autopublish` and `insecure`
packages, which together mimic the effect of each client having full
read/write access to the server's database.  These are useful
prototyping tools, but typically not appropriate for production
applications.  When you're ready, just remove the packages.
{{/note}}

Every Meteor client includes an in-memory database cache.  To manage the
client cache, the server *publishes* sets of JSON documents, and the
client *subscribes* to those sets.  As documents in a set change, the
server patches each client's cache.

Today most Meteor apps use MongoDB as their database because it is the
best supported, though support for other databases is coming in the
future. The
[`Meteor.Collection`](http://docs.meteor.com/#meteor_collection) class
is used to declare Mongo collections and to manipulate them. Thanks to
`minimongo`, Meteor's client-side Mongo emulator, `Meteor.Collection`
can be used from both client and server code.

    // declare collections
    // this code should be included in both the client and the server
    Rooms = new Meteor.Collection("rooms");
    Messages = new Meteor.Collection("messages");
    Parties = new Meteor.Collection("parties");

    // server: populate collections with some initial documents
    Rooms.insert({name: "Conference Room A"});
    var myRooms = Rooms.find({}).fetch();
    Messages.insert({text: "Hello world", room: myRooms[0]._id});
    Parties.insert({name: "Super Bowl Party"});

Each document set is defined by a publish function on the server.  The
publish function runs each time a new client subscribes to a document
set.  The data in a document set can come from anywhere, but the common
case is to publish a database query.

    // server: publish all room documents
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    });

    // server: publish all messages for a given room
    Meteor.publish("messages", function (roomId) {
      check(roomId, String);
      return Messages.find({room: roomId});
    });

    // server: publish the set of parties the logged-in user can see.
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

Publish functions can provide different results to each client.  In the
last example, a logged in user can only see `Party` documents that
are public, that the user owns, or that the user has been invited to.

Once subscribed, the client uses its cache as a fast local database,
dramatically simplifying client code.  Reads never require a costly
round trip to the server.  And they're limited to the contents of the
cache: a query for every document in a collection on a client will only
return documents the server is publishing to that client.

    // client: start a parties subscription
    Meteor.subscribe("parties");

    // client: return array of Parties this client can read
    return Parties.find().fetch(); // synchronous!

Sophisticated clients can turn subscriptions on and off to control how
much data is kept in the cache and manage network traffic.  When a
subscription is turned off, all its documents are removed from the cache
unless the same document is also provided by another active
subscription.

When the client *changes* one or more documents, it sends a message to
the server requesting the change.  The server checks the proposed change
against a set of allow/deny rules you write as JavaScript functions.
The server only accepts the change if all the rules pass.

    // server: don't allow client to insert a party
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // client: this will fail
    var party = { ... };
    Parties.insert(party);

If the server accepts the change, it applies the change to the database
and automatically propagates the change to other clients subscribed to
the affected documents.  If not, the update fails, the server's database
remains untouched, and no other client sees the update.

Meteor has a cute trick, though.  When a client issues a write to the
server, it also updates its local cache immediately, without waiting for
the server's response.  This means the screen will redraw right away.
If the server accepted the update &mdash; what ought to happen most of the
time in a properly behaving client &mdash; then the client got a jump on the
change and didn't have to wait for the round trip to update its own
screen.  If the server rejects the change, Meteor patches up the
client's cache with the server's result.

Putting it all together, these techniques accomplish latency
compensation.  Clients hold a fresh copy of the data they need, and
never need to wait for a roundtrip to the server. And when clients
modify data, those modifications can run locally without waiting for the
confirmation from the server, while still giving the server final say
over the requested change.

<h3 id="dataandsecurity-authentication">Authentication and user accounts</h3>

Meteor includes [Meteor Accounts](#accounts_api), a state-of-the-art
authentication system. It features secure password login using the
[Secure Remote Password
protocol](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol),
and integration with external services including Facebook, GitHub,
Google, Meetup, Twitter, and Weibo. Meteor Accounts defines a
[`Meteor.users`](#meteor_users) collection where developers can store
application-specific user data.

Meteor also includes pre-built forms for common tasks like login, signup,
password change, and password reset emails. You can add [Accounts
UI](#accountsui) to your app with just one line of code. The `accounts-ui` smart
package even provides a configuration wizard that walks you through the steps to
set up the external login services you're using in your app.

{{#note}}
The current release of Meteor supports MongoDB, the popular document
database, and the examples in this section use the
        [MongoDB API](http://www.mongodb.org/display/DOCS/Manual).  Future
releases will include support for other databases.
{{/note}}


<h3 id="dataandsecurity-validation">Input validation</h3>

Meteor allows your methods and publish functions to take arguments of any
[JSON](http://json.org/) type. (In fact, Meteor's wire protocol supports
[EJSON](#ejson), an extension of JSON which also supports other common types
like dates and binary buffers.) JavaScript's dynamic typing means you don't need
to declare precise types of every variable in your app, but it's usually helpful
to ensure that the arguments that clients are passing to your methods and
publish functions are of the type that you expect.

Meteor provides a [lightweight library](#match) for checking that arguments and
other values are the type you expect them to be. Simply start your functions
with statements like `check(username, String)` or
`check(office, {building: String, room: Number})`. The `check` call will
throw an error if its argument is of an unexpected type.

Meteor also provides an easy way to make sure that all of your methods
and publish functions validate all of their arguments. Just run
<code>meteor add [audit-argument-checks](#auditargumentchecks)</code> and any
method or publish function which skips `check`ing any of its arguments will fail
with an exception.

{{/better_markdown}}
</template>

<template name="reactivity">
{{#better_markdown}}

<h2 id="reactivity">响应式</h2>

Meteor 信奉[响应式编程](http://en.wikipedia.org/wiki/Reactive_programming)的理念。
这意味着，你可以用简单的命令式风格写代码，当你的代码所依赖的数据发生变化时，结果
会自动重新计算。

    Deps.autorun(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

这个例子（来自一个聊天室客户端）设置了一个基于会话变量 `currentRoomId` 的数据订阅。
如果 `Session.get("currentRoomId")` 因为任何原因发生变化，函数就会自动重新运行，然后
设置一个新的订阅来替代旧的。

自动重计算靠 `Session` 和 `Deps.autorun` 的协同来实现。`Deps.autorun` 在内部执行任意
“响应式计算”来追踪数据依赖性，然后它会重新执行它所必要的函数参数。另一方面，像
`Session` 等数据提供者，在计算中记录下他们被谁调用和哪些数据被请求，然后准备好当数据
发生改变时向计算发送一个失效信号。

这种简单模式（响应式计算 + 响应式数据源）有着广泛的适应性。以上使程序员免于编写
取消订阅调用/重新订阅调用以确保它们在正确的时间被调用。通常 Meteor 能消除全部类型的
数据传输代码，否则易错的逻辑将堵塞你的应用。

这些 Meteor 函数会像响应式计算一样运行你的代码：

* [Templates](#templates)
* [`Meteor.render`](#meteor_render) and [`Meteor.renderList`](#meteor_renderlist)
* [`Deps.autorun`](#deps_autorun)

能够触发变化的响应式数据源：

* [`Session`](#session) variables
* Database queries on [Collections](#find)
* [`Meteor.status`](#meteor_status)
* The `ready()` method on a [subscription handle](#meteor_subscribe)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

此外，下列函数会用 `stop` 类函数返回一个对象，如果调用来自一个响应式计算，
当计算重新运行或停止运行时，函数会停止。

* [`Deps.autorun`](#deps_autorun) (nested)
* [`Meteor.subscribe`](#meteor_subscribe)
* [`observe()`](#observe) and [`observeChanges()`](#observe_changes) on cursors

Meteor 的[实现](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)
是一个相当短和简单的名为 [`Deps`](#deps) 的包。你可以自己使用它去实现新的响应式数据源。

{{/better_markdown}}
</template>

<template name="livehtml">
{{#better_markdown}}

<h2 id="livehtml">实时 HTML</h2>

HTML 模板是 Web 应用程序的核心。使用 Meteor 实时页面更新技术，你可以响应式地渲染你的 HTML，这意味着它将根据数据的改变而自动更新。

这个可选择的特性可以应用于任何 HTML 模板库，甚至你从 JavaScript 手动生成的 HTML 也可以。这里有个例子：

    var fragment = Meteor.render(
      function () {
        var name = Session.get("name") || "Anonymous";
        return "<div>Hello, " + name + "</div>";
      });
    document.body.appendChild(fragment);

    Session.set("name", "Bob"); // 页面会自动更新！

[`Meteor.render`](#meteor_render) 接收一个渲染函数，这个函数会以字符串形式返回一些 HTML。而 [`Meteor.render`](#meteor_render) 返回一个自动更新的 `DocumentFragment`，当渲染函数使用的数据发生改变时重新运行。随后 `DocumentFragment` 中的 DOM 节点就会自动更新，无论这些节点在页面上的什么位置。整个过程是完全自动的。[`Meteor.render`](#meteor_render) 使用 [reactive computation](#reactivity) 来发现渲染函数使用的是哪些数据。

但大多数时候，你不用直接调用这些函数——你只需要使用你最喜欢模板库，比如 Handlebars 或者 Jade。`render` 和 `renderList` 函数是为了那些要实现新模板系统的人而准备的。

Meteor 一般只在你的代码不运行时批量执行所有必要的更新。这样，可以保证 DOM 不会背着你发生变化。不过有时候你会需要相反的行为，比如：如果你刚刚在数据库中插入一条记录，也许想强制 DOM 更新，以便使用 jQuery 这样的库来查找新的元素。这种情况下，可以使用 [`Deps.flush`](#deps_flush) 让 DOM 更新。

当从屏幕上拿掉实时更新的 DOM 元素时，它们会被自动清除——它们的回调函数会被销毁，任何相关的数据库操作会停止，DOM 元素也会停止更新。因为这样的原因，你无需担心 [zombie
templates](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/) 给手写的更新逻辑造成灾难。为了保护你的元素不被清除，只需保证在代码返回给事件循环前，或者在你调用 [`Deps.flush`](#deps_flush) 前，它们还在屏幕上即可。

手写应用程序的另一个棘手的问题是元素保留。假设用户正在一个 `<input>` 元素中打字，然后页面中包含这个元素的区域重绘了。这时候用户就麻烦了，在 `<input>` 重建时焦点、光标位置、已经输入的部分文字和带重音符号的输入状态都会丢失。

这是 Meteor 为你解决的又一个问题。当有 [`preserve`](#template_preserve) 指令的模板被重新渲染的时候，你可以指定保留一部分元素。这样，即使包含它们的模板被重新渲染了，Meteor 也将保留这些元素，不过仍然会更新它们的子元素并复制所有的属性变化。

{{/better_markdown}}
</template>

<template name="templates">
{{#better_markdown}}

<h2 id="templates">模板</h2>

Meteor 的实时页面更新技术可以使你很轻松地使用你喜欢的 HTML 模板语言，
像 Handlebars 和 Jade。只要如往常一样写你的模板，Meteor 会负责即时更新
它。

要使用这个特性，在你的项目中使用扩展名 `.html` 创建一个文件。在文件中，
构造一个 `<template>` 标签并给它一个 `name` 属性。在标签中放置模板内容。
Meteor 会预编译模板，运送它到客户端，然后使它可以在全局 `Template`
对象中作为一个有效的函数。


{{#note}}
现在，在 Meteor 中被打包的模板只有 Handlebars。请让我们知道：在 Meteor 中，
你想使用什么模板系统。同时，请看 [Handlebars documentation](http://www.handlebarsjs.com/)
和 [Meteor Handlebars extensions](https://github.com/meteor/meteor/wiki/Handlebars)
{{/note}}

一个 `name` 属性为 `hello` 的模板会调用函数 `Template.hello` 来渲染，
然后传递模板中的所有数据：

    <!-- in myapp.html -->
    <template name="hello">
      <div class="greeting">Hello there, {{dstache}}first}} {{dstache}}last}}!</div>
    </{{! }}template>

    // in the JavaScript console
    > Template.hello({first: "Alyssa", last: "Hacker"});
     => "<div class="greeting">Hello there, Alyssa Hacker!</div>"

这会返回一个字符串。要想把模板与 [`Live HTML`](#livehtml) 系统一同
使用，并在适当位置自动更新获取到的 DOM 元素，请用
[`Meteor.render`](#meteor_render)：

    Meteor.render(function () {
      return Template.hello({first: "Alyssa", last: "Hacker"});
    })
      => automatically updating DOM elements

获取模板中的数据的最简单的方法是在 JavaScript 中定义辅助函数。只要在
`Template.[template name]` 对象中直接加入辅助函数就可以了。例如，在这个
模板中：

    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    </{{! }}template>

我们可以通过定义函数 `Template.players`，来更换当传递数据
`topScorers` 时所调用模板函数：

    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

在这个实例中，数据来自数据库查询。一旦数据库游标传递给 `#each`，就会
高效地连接每一台机器，添加和移动 DOM 节点作为新的结果输入查询中。

辅助对象可以带参数，然后它们将收到在 `this` 函数中的当前模板的数据：

    // in a JavaScript file
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- in a HTML file -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    </{{! }}template>

{{#note}}
关于 Handlebars 的提示： `{{dstache}}#if leagueIs "junior"}}` 是可以使用的，
因为 Meteor 扩展模块允许在一个块辅助对象中嵌套一个辅助对象。（`if` 和
`leagueIs` 都是严格意义上的辅助对象，标准的 Handlebars 模板不会在这里调用
`leagueIs` 函数。
{{/note}}

辅助对象也可以用来传递常量数据。

    // Works fine with {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

最后，你可以在一个模板函数中使用一个 `events` 声明来建立一个事件处理函数表，这个
格式被记录在 [Event Maps](#eventmaps)。事件处理函数的 `this` 参数会成为触发事件
元素中的数据上下文。

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    </{{! }}template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    </{{! }}template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update(this._id, {$inc: {score: 2}});
      }
    });

把它们整理在一起，这就是一个关于你如何在你的模板中注入任意数据、并在数据
改变时自动更新它们的例子。更多讨论请看 [Live HTML](#livehtml)。

    <!-- in myapp.html -->
    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    </{{! }}template>

    <!-- in myapp.js -->
    // JavaScript: reactive helper function
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    <!-- in the console -->
    > Session.set("weather", "cloudy");
    > document.body.appendChild(Meteor.render(Template.forecast));
    In DOM:  <div>It'll be cloudy tonight</div>

    > Session.set("weather", "cool and dry");
    In DOM:  <div>It'll be cool and dry tonight</div>

{{/better_markdown}}
</template>

<template name="packages_concept">
{{#better_markdown}}

  <h2 id="smartpackages">智能的包</h2>

Meteor 有着异常强大的包系统，你读到的所有功能都已经被实现为标准的 Meteor 包。

Meteor 的包是智能的：包本身就是 JavaScript 程序。它们可以注入到客户端和服务端，或者在 bundler 中 hook 一个新的函数，所以它们可以用任意方式扩展 Meteor 环境。一些包的例子：

* [coffeescript](#coffeescript) 的包扩展了 bundler，自动编译目录中的 `.coffee` 文件。添加后，你可以用 CoffeeScript 代替 JavaScript 开发你的应用。

* [jQuery](#jquery) 和 [Backbone](#backbone) 的包是 Meteor 客户端预装的 JavaScript 库。你可以通过把 JavaScript 文件复制到目录中得到同样的结果，但添加包是更快的方式。

* [underscore](#underscore) 的包扩展了客户端和服务端环境。

在很多 Meteor 的核心特性被自动作为内置包在每个 Meteor 环境中加载（包含了 Minimongo、Session 对象和反应的 Handlebars 模板）。

你可以在这里 [`meteor list`](#meteorlist) 看到 Meteor 可用包的列表，通过 [`meteor add`](#meteoradd) 添加包到你的项目里，通过 [`meteor remove`](#meteorremove) 移除它们。

在 [Package List](#packages) 这里来看现有包的描述。

{{#warning}}
包的 API 是快速变化的并且不会被记录，所以你现在不能制作自己的包。很快就可以。
{{/warning}}

{{/better_markdown}}
</template>





<template name="deploying">
{{#better_markdown}}

<h2 id="deploying">部署</h2>

Meteor 是一个完整的应用程序服务器。我们在程序中包含了把程序部署在网络
上所需要的一切：你只要准备 JavaScript、HTML 和 CSS 就够了。

<h3 class="nosection">运行 Meteor 的基础结构</h3>

部署程序最容易的方法是使用 `meteor deploy`。我们提供它是因为我们总是想要：
一种可以实现程序创意的而又不妨碍创造力、能在一个周末内赋予其血肉、然后
把它放在那里供全世界使用的简单方法。

    $ meteor deploy myapp.meteor.com

你的程序现在可以使用 myapp.meteor.com。如果你是第一次部署程序到这个
主机名，Meteor 会为你的程序创建一个新的空数据库。如果你想更新程序，
Meteor 会保存现有数据并且刷新代码。

你也可以在自己的域名上部署程序。只要把你想要使用的主机名做 CNAME 记录
指向 `origin.meteor.com`，然后部署到上面就可以了。

    $ meteor deploy www.myapp.com

你可以在我们提供的免费服务上尝试 Meteor。它也可以帮你很快地建造内部
测试程序、演示程序等等。

<h3 class="nosection">运行你自己的基础结构</h3>

你也可以在你自己的基础结构上运行程序，或者使用像 Heroku 等其他托管服务商。

想要马上开始，运行

    $ meteor bundle myapp.tgz

这个命令会以 tarball 档案的形式创建一个完全独立的 Node.js 程序。想要运行
这个程序，你需要安装 Node.js 0.8 和一个 MongoDB 服务器。然后你可以通过
调用 Node.js、指定程序监听的端口和 MongoDB 的路径来运行这个程序。如果你没有
MongoDB 服务器，我们可以为你推荐我们朋友的 [MongoHQ](http://mongohq.com)。

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

其他包可能需要其他环境变量（例如 `email` 包需要 `MAIL_URL` 环境变量）。

{{#warning}}
目前，打包好的程序只能运行在创建它的平台上。想要运行在另一个平台上，你需要
重新打包本地包。先确认你是否有 `npm`，然后运行：

    $ cd bundle/server/node_modules
    $ rm -r fibers
    $ npm install fibers@1.0.0
{{/warning}}

{{/better_markdown}}
</template>
